<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bumps.mapper &#8212; Bumps 0.9.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css?v=601dbdee" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script src="../../_static/documentation_options.js?v=9dc39874"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Bumps 0.9.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../bumps.html" accesskey="U">bumps</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">bumps.mapper</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for bumps.mapper</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Parallel and serial mapper implementations.</span>

<span class="sd">The API is a bit crufty since interprocess communication has evolved from</span>
<span class="sd">the original implementation. And the names are misleading.</span>

<span class="sd">Usage::</span>

<span class="sd">    Mapper.start_worker(problem)</span>
<span class="sd">    mapper = Mapper.start_mapper(problem, None, cpus)</span>
<span class="sd">    result = mapper(points)</span>
<span class="sd">    ...</span>
<span class="sd">    mapper = Mapper.start_mapper(problem, None, cpus)</span>
<span class="sd">    result = mapper(points)</span>
<span class="sd">    Mapper.stop_mapper(mapper)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># {{{ http://code.activestate.com/recipes/496767/ (r1)</span>
<span class="c1"># Converted to use ctypes by Paul Kienzle</span>


<span class="n">PROCESS_ALL_ACCESS</span> <span class="o">=</span> <span class="mh">0x1F0FFF</span>

<div class="viewcode-block" id="can_pickle">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.can_pickle">[docs]</a>
<span class="k">def</span> <span class="nf">can_pickle</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if *problem* can be pickled.</span>

<span class="sd">    If this method returns False then MPMapper cannot be used and</span>
<span class="sd">    SerialMapper should be used instead.</span>

<span class="sd">    If *check* is True then call *nllf()* on the duplicated object as a</span>
<span class="sd">    &quot;smoke test&quot; to verify that the function will run after copying. This</span>
<span class="sd">    is not foolproof. For example, access to a database may work in the</span>
<span class="sd">    duplicated object because the connection is open and available in the</span>
<span class="sd">    current process, but it will fail when trying to run on a remote machine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">dill</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">dill</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dill</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dup</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dup</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">problem</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">dup</span><span class="o">.</span><span class="n">nllf</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="setpriority">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.setpriority">[docs]</a>
<span class="k">def</span> <span class="nf">setpriority</span><span class="p">(</span><span class="n">pid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set The Priority of a Windows Process.  Priority is a value between 0-5</span>
<span class="sd">    where 2 is normal priority and 5 is maximum.  Default sets the priority</span>
<span class="sd">    of the current python process but can take any valid process ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#import win32api,win32process,win32con</span>
    <span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">windll</span>

    <span class="n">priorityclasses</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x40</span><span class="p">,</span>   <span class="c1"># IDLE_PRIORITY_CLASS,</span>
                       <span class="mh">0x4000</span><span class="p">,</span>  <span class="c1"># BELOW_NORMAL_PRIORITY_CLASS,</span>
                       <span class="mh">0x20</span><span class="p">,</span>   <span class="c1"># NORMAL_PRIORITY_CLASS,</span>
                       <span class="mh">0x8000</span><span class="p">,</span>  <span class="c1"># ABOVE_NORMAL_PRIORITY_CLASS,</span>
                       <span class="mh">0x80</span><span class="p">,</span>   <span class="c1"># HIGH_PRIORITY_CLASS,</span>
                       <span class="mh">0x100</span><span class="p">,</span>  <span class="c1"># REALTIME_PRIORITY_CLASS</span>
                      <span class="p">]</span>
    <span class="k">if</span> <span class="n">pid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetCurrentProcessId</span><span class="p">()</span>
    <span class="n">handle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
    <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">SetPriorityClass</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">priorityclasses</span><span class="p">[</span><span class="n">priority</span><span class="p">])</span></div>

<span class="c1"># end of http://code.activestate.com/recipes/496767/ }}}</span>


<div class="viewcode-block" id="nice">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.nice">[docs]</a>
<span class="k">def</span> <span class="nf">nice</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;nt&#39;</span><span class="p">:</span>
        <span class="n">setpriority</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">nice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span></div>



<div class="viewcode-block" id="SerialMapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.SerialMapper">[docs]</a>
<span class="k">class</span> <span class="nc">SerialMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<div class="viewcode-block" id="SerialMapper.start_worker">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.SerialMapper.start_worker">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_worker</span><span class="p">(</span><span class="n">problem</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="SerialMapper.start_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.SerialMapper.start_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_mapper</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">modelargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cpus</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># Note: map is n iterator in python 3.x</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">problem</span><span class="o">.</span><span class="n">nllf</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span></div>


<div class="viewcode-block" id="SerialMapper.stop_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.SerialMapper.stop_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stop_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
        <span class="k">pass</span></div>
</div>



<span class="c1"># Load the problem in the remote process rather than pickling</span>
<span class="c1">#def _MP_load_problem(*modelargs):</span>
<span class="c1">#    from .fitproblem import load_problem</span>
<span class="c1">#    _MP_set_problem(load_problem(*modelargs))</span>

<span class="k">def</span> <span class="nf">_MP_setup</span><span class="p">(</span><span class="n">namespace</span><span class="p">):</span>
    <span class="c1"># Using MPMapper class variables to store worker globals.</span>
    <span class="c1"># It doesn&#39;t matter if they conflict with the controller values since</span>
    <span class="c1"># they are in a different process.</span>
    <span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span>
    <span class="n">nice</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_MP_run_problem</span><span class="p">(</span><span class="n">problem_point_pair</span><span class="p">):</span>
    <span class="n">problem_id</span><span class="p">,</span> <span class="n">point</span> <span class="o">=</span> <span class="n">problem_point_pair</span>
    <span class="k">if</span> <span class="n">problem_id</span> <span class="o">!=</span> <span class="n">MPMapper</span><span class="o">.</span><span class="n">problem_id</span><span class="p">:</span>
        <span class="c1">#print(f&quot;Fetching problem {problem_id} from namespace&quot;)</span>
        <span class="c1"># Problem is pickled using dill when it is available</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">dill</span>
            <span class="n">MPMapper</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">pickled_problem</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">MPMapper</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">problem</span>
        <span class="n">MPMapper</span><span class="o">.</span><span class="n">problem_id</span> <span class="o">=</span> <span class="n">problem_id</span>
    <span class="k">return</span> <span class="n">MPMapper</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">nllf</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>


<div class="viewcode-block" id="MPMapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPMapper">[docs]</a>
<span class="k">class</span> <span class="nc">MPMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Note: suprocesses are using the same variables</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">namespace</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">problem_id</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="MPMapper.start_worker">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPMapper.start_worker">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_worker</span><span class="p">(</span><span class="n">problem</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MPMapper.start_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPMapper.start_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_mapper</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">modelargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cpus</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">multiprocessing</span>

        <span class="c1"># Set up the process pool on the first call.</span>
        <span class="k">if</span> <span class="n">MPMapper</span><span class="o">.</span><span class="n">pool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create a sync namespace to distribute the problem description.</span>
            <span class="n">MPMapper</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
            <span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">MPMapper</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">Namespace</span><span class="p">()</span>
            <span class="c1"># Start the process pool, sending the namespace handle</span>
            <span class="k">if</span> <span class="n">cpus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cpus</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
            <span class="n">MPMapper</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">_MP_setup</span><span class="p">,</span> <span class="p">(</span><span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span><span class="p">,))</span>

        <span class="c1"># Increment the problem number and store the problem in the namespace.</span>
        <span class="c1"># The store action uses pickle to transfer python objects to the</span>
        <span class="c1"># manager process. Since this may fail for lambdas and for functions</span>
        <span class="c1"># defined within the model file, instead use dill (if available)</span>
        <span class="c1"># to pickle the problem before storing.</span>
        <span class="n">MPMapper</span><span class="o">.</span><span class="n">problem_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">dill</span>
            <span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">pickled_problem</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">problem</span>
        <span class="c1">## Store the modelargs and the problem name if pickling doesn&#39;t work</span>
        <span class="c1">#MPMapper.namespace.modelargs = modelargs</span>

        <span class="c1"># Set the mapper to send problem_id/point value pairs</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">points</span><span class="p">:</span> <span class="n">MPMapper</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="n">_MP_run_problem</span><span class="p">,</span> <span class="p">((</span><span class="n">MPMapper</span><span class="o">.</span><span class="n">problem_id</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mapper</span></div>


<div class="viewcode-block" id="MPMapper.stop_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPMapper.stop_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stop_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
        <span class="c1"># reset pool and manager</span>
        <span class="n">MPMapper</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="n">MPMapper</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
        <span class="n">MPMapper</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">MPMapper</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">MPMapper</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="kc">None</span></div>
</div>

        <span class="c1"># Don&#39;t reset problem id; it keeps count even when mapper is restarted.</span>
        <span class="c1">##MPMapper.problem_id = 0</span>

<span class="k">def</span> <span class="nf">_MPI_set_problem</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">dill</span>
    <span class="n">pickled_problem</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="n">root</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">pickled_problem</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">pickled_problem</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">problem</span> <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="n">root</span> <span class="k">else</span> <span class="n">dill</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickled_problem</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_MPI_map</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1">#print(f&quot;{comm.rank}: mapping points&quot;)</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>

    <span class="c1"># Send number of points and number of variables per point.</span>
    <span class="c1"># root: return result if there are points otherwise return False</span>
    <span class="c1"># worker: return True if there are points otherwise return False</span>
    <span class="n">npoints</span><span class="p">,</span> <span class="n">nvars</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span>
        <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="n">root</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">npoints</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Divvy points equally across all processes</span>
    <span class="n">whole</span> <span class="o">=</span> <span class="n">points</span> <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="n">root</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> \
        <span class="p">(</span><span class="n">npoints</span> <span class="o">//</span> <span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">npoints</span> <span class="o">%</span> <span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
    <span class="n">part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">size</span><span class="p">[</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">],</span> <span class="n">nvars</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Scatterv</span><span class="p">((</span><span class="n">whole</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">nvars</span><span class="p">,</span> <span class="n">offset</span> <span class="o">*</span> <span class="n">nvars</span><span class="p">),</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span>
                  <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>

    <span class="c1"># Evaluate models assigned to each processor</span>
    <span class="n">partial_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">problem</span><span class="o">.</span><span class="n">nllf</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span> <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">part</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1"># Collect results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">npoints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="n">root</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Gatherv</span><span class="p">((</span><span class="n">partial_result</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span>
                 <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span>
                 <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="MPIMapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPIMapper">[docs]</a>
<span class="k">class</span> <span class="nc">MPIMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">_first_fit</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># The first problem is set when the worker starts</span>

<div class="viewcode-block" id="MPIMapper.start_worker">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPIMapper.start_worker">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_worker</span><span class="p">(</span><span class="n">problem</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start the worker process.</span>

<span class="sd">        For the main process this does nothing and returns immediately. The</span>
<span class="sd">        worker processes never return.</span>

<span class="sd">        Each worker sits in a loop waiting for the next batch of points</span>
<span class="sd">        for the problem, or for the next problem. Set t</span>
<span class="sd">        problem is set to None, then exit the process and never </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="mi">0</span>

        <span class="c1"># If worker, sit in a loop waiting for the next point.</span>
        <span class="c1"># If the point is empty, then wait for a new problem.</span>
        <span class="c1"># If the problem is None then we are done, otherwise wait for next point.</span>
        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="n">root</span><span class="p">:</span>
            <span class="c1">#print(f&quot;{comm.rank}: looping&quot;)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_MPI_map</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">problem</span> <span class="o">=</span> <span class="n">_MPI_set_problem</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">problem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="c1">#print(f&quot;{comm.rank}: changing problem&quot;)</span>

            <span class="c1">#print(f&quot;{comm.rank}: finalizing&quot;)</span>
            <span class="n">MPI</span><span class="o">.</span><span class="n">Finalize</span><span class="p">()</span>

            <span class="c1"># Exit the program after the worker is done. Don&#39;t return</span>
            <span class="c1"># to the caller since that is continuing on with the main</span>
            <span class="c1"># thread, and in particular, attempting to rerun the fit on</span>
            <span class="c1"># each worker.</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="MPIMapper.start_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPIMapper.start_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_mapper</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">modelargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cpus</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># Only root can get here---worker is stuck in start_worker</span>
        <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="mi">0</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="c1"># Signal new problem then send it, but not on the first fit. We do this</span>
        <span class="c1"># so that we can still run MPI fits even if the problem itself cannot</span>
        <span class="c1"># be pickled, but only the first one. (You can still fit a series even</span>
        <span class="c1"># if the problem can&#39;t be pickled, but you will need to restart the</span>
        <span class="c1"># MPI job separately for each fit.)</span>
        <span class="c1"># Note: setting problem to None stops the program, so call finalize().</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">points</span><span class="p">:</span> <span class="n">_MPI_map</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">MPIMapper</span><span class="o">.</span><span class="n">_first_fit</span><span class="p">:</span>
            <span class="c1">#print(f&quot;{comm.rank}: replacing problem&quot;)</span>
            <span class="c1"># Send an empty set of points to signal a new problem is coming.</span>
            <span class="n">mapper</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">))</span>
            <span class="n">_MPI_set_problem</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">problem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#print(f&quot;{comm.rank}: finalizing root&quot;)</span>
                <span class="n">MPI</span><span class="o">.</span><span class="n">Finalize</span><span class="p">()</span>
        <span class="n">MPIMapper</span><span class="o">.</span><span class="n">_first_fit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">mapper</span></div>


<div class="viewcode-block" id="MPIMapper.stop_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.MPIMapper.stop_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stop_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
        <span class="c1"># Set problem=None to stop the program.</span>
        <span class="n">MPIMapper</span><span class="o">.</span><span class="n">start_mapper</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="AMQPMapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.AMQPMapper">[docs]</a>
<span class="k">class</span> <span class="nc">AMQPMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<div class="viewcode-block" id="AMQPMapper.start_worker">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.AMQPMapper.start_worker">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_worker</span><span class="p">(</span><span class="n">problem</span><span class="p">):</span>
        <span class="c1">#sys.stderr = open(&quot;bumps-%d.log&quot;%os.getpid(),&quot;w&quot;)</span>
        <span class="c1">#print &gt;&gt;sys.stderr,&quot;worker is starting&quot;; sys.stdout.flush()</span>
        <span class="kn">from</span> <span class="nn">amqp_map.config</span> <span class="kn">import</span> <span class="n">SERVICE_HOST</span>
        <span class="kn">from</span> <span class="nn">amqp_map.core</span> <span class="kn">import</span> <span class="n">connect</span><span class="p">,</span> <span class="n">start_worker</span> <span class="k">as</span> <span class="n">serve</span>
        <span class="n">server</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">SERVICE_HOST</span><span class="p">)</span>
        <span class="c1">#os.system(&quot;echo &#39;serving&#39; &gt; /tmp/map.%d&quot;%(os.getpid()))</span>
        <span class="c1"># print &quot;worker is serving&quot;; sys.stdout.flush()</span>
        <span class="n">serve</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="s2">&quot;bumps&quot;</span><span class="p">,</span> <span class="n">problem</span><span class="o">.</span><span class="n">nllf</span><span class="p">)</span></div>

        <span class="c1">#print &gt;&gt;sys.stderr,&quot;worker ended&quot;; sys.stdout.flush()</span>

<div class="viewcode-block" id="AMQPMapper.start_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.AMQPMapper.start_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">start_mapper</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">modelargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cpus</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">sys</span>
        <span class="kn">import</span> <span class="nn">multiprocessing</span>
        <span class="kn">import</span> <span class="nn">subprocess</span>
        <span class="kn">from</span> <span class="nn">amqp_map.config</span> <span class="kn">import</span> <span class="n">SERVICE_HOST</span>
        <span class="kn">from</span> <span class="nn">amqp_map.core</span> <span class="kn">import</span> <span class="n">connect</span><span class="p">,</span> <span class="n">Mapper</span>

        <span class="n">server</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">SERVICE_HOST</span><span class="p">)</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">Mapper</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="s2">&quot;bumps&quot;</span><span class="p">)</span>
        <span class="n">cpus</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="n">pipes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cpus</span><span class="p">):</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;--worker&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">modelargs</span>
            <span class="c1"># print &quot;starting&quot;,sys.argv[0],&quot;in&quot;,os.getcwd(),&quot;with&quot;,cmd</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
            <span class="n">pipes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pipe</span> <span class="ow">in</span> <span class="n">pipes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pipe</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;subprocess returned </span><span class="si">%d</span><span class="se">\n</span><span class="s2">out: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">err: </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">pipe</span><span class="o">.</span><span class="n">returncode</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>
        <span class="c1">#os.system(&quot; &quot;.join(cmd+[&quot;&amp;&quot;]))</span>
        <span class="kn">import</span> <span class="nn">atexit</span>

        <span class="k">def</span> <span class="nf">exit_fun</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pipes</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">exit_fun</span><span class="p">)</span>

        <span class="c1"># print &quot;returning mapper&quot;,mapper</span>
        <span class="k">return</span> <span class="n">mapper</span></div>


<div class="viewcode-block" id="AMQPMapper.stop_mapper">
<a class="viewcode-back" href="../../bumps.mapper.html#bumps.mapper.AMQPMapper.stop_mapper">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stop_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pipe</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">pipes</span><span class="p">:</span>
            <span class="n">pipe</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Bumps 0.9.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../bumps.html" >bumps</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">bumps.mapper</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>