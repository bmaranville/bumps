<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Fitting Poisson data &#8212; Bumps 0.9.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css?v=601dbdee" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script src="../../_static/documentation_options.js?v=9dc39874"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Poisson simulation" href="sim.html" />
    <link rel="prev" title="Fitting a curve" href="curve.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sim.html" title="Poisson simulation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="curve.html" title="Fitting a curve"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Bumps 0.9.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Tutorial</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="readme.html" accesskey="U">Simple functions</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Fitting Poisson data</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="fitting-poisson-data">
<h1>Fitting Poisson data<a class="headerlink" href="#fitting-poisson-data" title="Link to this heading">¶</a></h1>
<p>Data from poisson processes, such as the number of counts per unit time
or counts per unit area, do not have the same pattern of uncertainties
as data from gaussian processes.  Poisson data consists of natural
numbers occurring at some underlying rate.  The fitting process checks
if the number of counts observed is consistent with the proposed rate
for each point in the dataset, much like the fitting process for gaussian
data checks if the observed value is consistent with the proposed value
within the measurement uncertainty.</p>
<p>Using <a class="reference internal" href="../../bumps.curve.html#bumps.curve.PoissonCurve" title="bumps.curve.PoissonCurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">bumps.curve.PoissonCurve</span></code></a> instead of <a class="reference internal" href="../../bumps.curve.html#bumps.curve.Curve" title="bumps.curve.Curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">bumps.curve.Curve</span></code></a>,
we can fit a set of <em>counts</em> at conditions <em>x</em> using a function
<em>f(x, p1, p2, …)</em> to propose rates for the various <em>x</em> values given the
parameters, yielding parameter values <em>p1, p2, …</em> that are most consistent
with the <em>counts</em> at <em>x</em>. When measuring poisson processes, the underlying
rate is not known, so the measurement variance, which is a property of the
rate, is not associated with the data but instead associated with the
theory function which predicts the rates.  This is opposite from what we
have with gaussian data, in which the uncertainty is associated with the
measurement device, and explains why the call to PoissonCurve only accepts
<em>x</em> and <em>counts</em>, not <em>x</em>, <em>y</em>, and <em>dy</em>.</p>
<p>One property of the Poisson distribution is that it is well approximated
by a gaussian distribution for values above about 10.   It will never be
perfect match since numbers from a poisson distribution can never be
negative, whereas gaussian numbers can always be negative, albeit with
vanishingly small probability some of the time.  Below 10, there are
various ways you can approximate the poisson distribution with a gaussian.
This example explores some of the options.</p>
<p>In particular, the handling of zero counts can be problematic when treating
the measurement as gaussian.  You cannot simply drop the points with zero
counts. Once you’ve done various reduction steps, the resulting non-zero
value for the uncertainty will carry meaning.  The longer you count,
the smaller the uncertainty should be, once you’ve normalized for counting
time or monitor.  Being off by a factor of 2 on the residuals is much
better than being off by a factor of infinity using uncertainty = zero,
and better than dropping the point altogether.</p>
<p>There are a few things you can do with zero counts without being
completely arbitrary:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\lambda = (k+1) \pm \sqrt{k+1}\)</span> for all <span class="math notranslate nohighlight">\(k\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda = (k+1/2) \pm \sqrt{k+1/4}\)</span> for all k</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda = k \pm \sqrt{k+1}\)</span> for all k</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda = k \pm \sqrt{k}\)</span> for <span class="math notranslate nohighlight">\(k&gt;0\)</span>, <span class="math notranslate nohighlight">\(1/2 \pm 1/2\)</span> for <span class="math notranslate nohighlight">\(k = 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda = k \pm \sqrt{k}\)</span> for <span class="math notranslate nohighlight">\(k&gt;0\)</span>, <span class="math notranslate nohighlight">\(0 \pm 1\)</span> for <span class="math notranslate nohighlight">\(k = 0\)</span></p></li>
</ol>
</div></blockquote>
<p>See the notes from the CDF Statistics Committee for details at
<a class="reference external" href="https://www-cdf.fnal.gov/physics/statistics/notes/pois_eb.txt">https://www-cdf.fnal.gov/physics/statistics/notes/pois_eb.txt</a>.</p>
<p>Of these, option 5 works slightly better for fitting, giving the best
estimate of the background.</p>
<p>The ideal case is to have your model produce an expected number of counts
on the detector.  It is then trivial to compute the probability of
seeing the observed counts from the expected counts and fit the parameters
using PoissonCurve.  Unfortunately, this means incorporating all
instrumental effects when modelling the measurement rather than correcting
for instrumental effects in a data reduction program, and using a common
sample model independent of instrument.</p>
<p>Setting <span class="math notranslate nohighlight">\(\lambda = k\)</span> is good since that is the maximum likelihood value
for <span class="math notranslate nohighlight">\(\lambda\)</span> given observed <span class="math notranslate nohighlight">\(k\)</span>, but this breaks down at <span class="math notranslate nohighlight">\(k=0\)</span>, giving zero
uncertainty regardless of how long we measured.</p>
<p>Since the Poisson distribution is slightly skew, a good estimate is
<span class="math notranslate nohighlight">\(\lambda = k+1\)</span> (option 1 above).  This follows from the formula for the
expected value of a distribution:</p>
<div class="math notranslate nohighlight">
\[E[x] = \int_{-\infty}^\infty x P(x) dx\]</div>
<p>For the poisson distribution, this is:</p>
<div class="math notranslate nohighlight">
\[E[\lambda] = \int_0^\infty \lambda \frac{\lambda^k e^{-\lambda}}{k!} d\lambda\]</div>
<p>Running some simulations, we can see that <span class="math notranslate nohighlight">\(\hat\lambda=(k+1)\pm\sqrt{k+1}\)</span>
(see <a class="reference external" href="sim.html">sim.py</a>). This is the best fit RMS value to the distribution
of possible <span class="math notranslate nohighlight">\(\lambda\)</span> values that could give rise to the observed <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>The current practice is to use <span class="math notranslate nohighlight">\(\hat\lambda=k\pm\sqrt{k}\)</span>. Convincing the
world to accept <span class="math notranslate nohighlight">\(\lambda = k+1\)</span> would be challenging since the expected
value is not the most likely value.  As a compromise, one can use <span class="math notranslate nohighlight">\(0 \pm 1\)</span>
for zero counts, and <span class="math notranslate nohighlight">\(k \pm \sqrt{k}\)</span> for other values. This provides a
reasonable estimate for the uncertainty on zero counts, which after
normalization becomes smaller for longer counting times or higher incident
flux.</p>
<p>Another option is to choose the center and bounds so that the
uncertainty covers <span class="math notranslate nohighlight">\(1-\sigma\)</span> from the distribution (68%).  A simple
approximation which does this is <span class="math notranslate nohighlight">\((n+1/2) \pm \sqrt{n+1/4}\)</span>.
Again, hard to convince the world to do, so one could compromise and
choose <span class="math notranslate nohighlight">\(1/2 \pm 1/2\)</span> for <span class="math notranslate nohighlight">\(k=0\)</span> and <span class="math notranslate nohighlight">\(k \pm \sqrt{k}\)</span> otherwise.</p>
<p>What follows is a model which allows us to fit a simulated peak using
these various definitions of <span class="math notranslate nohighlight">\(\lambda\)</span> and see which version best recovers
the true parameters which generated the peak.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bumps.names</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Define the peak shape.  We are using a simple gaussian with center, width,
scale and background.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">peak</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">background</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">scale</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">width</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">background</span>
</pre></div>
</div>
<p>Generate simulated peak data with poisson noise.  When running the fit,
you can choose various values for the peak intensity.  We are using a
large number of points so that the peak is highly constrained by the
data, and the returned parameters are consistent from run to run.  Real
data is likely not so heavily sampled.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">345</span><span class="p">)</span>
<span class="c1">#y = np.random.poisson(peak(x, 1000, 12, 1.0, 1))</span>
<span class="c1">#y = np.random.poisson(peak(x, 300, 12, 1.5, 1))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">peak</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Define the various conditions.  These can be selected on the command
line by listing the condition name after the model file.  Note that
bumps will make any option not preceded by “-” available to the model
file as elements of <em>sys.argv</em>.  <em>sys.argv[0]</em> is the model file itself.</p>
<p>The options correspond to the five options listed above, with an additional
option “poisson” which is used to select PoissonCurve rather than Curve
in the fit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cond</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;pearson&quot;</span>
<span class="k">if</span> <span class="n">cond</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span> <span class="c1"># option 0: use PoissonCurve rather than Curve to fit</span>
    <span class="k">pass</span>
<span class="k">elif</span> <span class="n">cond</span> <span class="o">==</span> <span class="s2">&quot;expected&quot;</span><span class="p">:</span> <span class="c1"># option 1: L = (y+1) +/- sqrt(y+1)</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">cond</span> <span class="o">==</span> <span class="s2">&quot;pearson&quot;</span><span class="p">:</span> <span class="c1"># option 2: L = (y + 0.5)  +/- sqrt(y + 1/4)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mf">0.25</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span>
<span class="k">elif</span> <span class="n">cond</span> <span class="o">==</span> <span class="s2">&quot;expected_mle&quot;</span><span class="p">:</span> <span class="c1"># option 3: L = y +/- sqrt(y+1)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">cond</span> <span class="o">==</span> <span class="s2">&quot;pearson_zero&quot;</span><span class="p">:</span> <span class="c1"># option 4: L = y +/- sqrt(y); L[0] = 0.5 +/- 0.5</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">dy</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="k">elif</span> <span class="n">cond</span><span class="o">==</span><span class="s2">&quot;expected_zero&quot;</span><span class="p">:</span> <span class="c1"># option 5: L = y +/- sqrt(y);  L[0] = 0 +/- 1</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">dy</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Need to select uncertainty: pearson, pearson_zero, expected, expected_zero, expected_mle, poisson&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Build the fitter, and set the range on the fit parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">cond</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">PoissonCurve</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">M</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">M</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mf">0.2</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mf">0.2</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
<span class="n">M</span><span class="o">.</span><span class="n">width</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.7</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
<span class="n">M</span><span class="o">.</span><span class="n">background</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>Set the fit problem as usual.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">problem</span> <span class="o">=</span> <span class="n">FitProblem</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now load and run the fit.  Be sure to substitute COND for one of the
conditions defined above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ bumps.py poisson.py --fit=dream --burn=600 --store=/tmp/T1 COND
</pre></div>
</div>
<p>Comparing the results for the various conditions, we can see that all methods
yield a good fit to the underlying center, scale and width.  It is only the
background that causes problems.  Using poisson statistics for the fit gives
the proper background estimate, and using the traditional method of
<span class="math notranslate nohighlight">\(\lambda = k \pm \sqrt{k}\)</span> for <span class="math notranslate nohighlight">\(k&gt;0\)</span>, and <span class="math notranslate nohighlight">\(0 \pm 1\)</span> for <span class="math notranslate nohighlight">\(k=1\)</span> gives the
best gaussian approximation.</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Fit results</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p>method</p></th>
<th class="head"><p>background</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>poisson</p></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>expected</p></td>
<td><p>1.55</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>pearson</p></td>
<td><p>0.16</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>expected_mle</p></td>
<td><p>0.55</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>pearson_zero</p></td>
<td><p>0.34</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>expected_zero</p></td>
<td><p>0.75</p></td>
</tr>
</tbody>
</table>
<p>Download: <a class="reference download internal" download="" href="../../_downloads/76e186550176513e88ba5764923b8c2a/poisson.py"><code class="xref download docutils literal notranslate"><span class="pre">poisson.py</span></code></a>.</p>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="curve.html"
                          title="previous chapter">Fitting a curve</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="sim.html"
                          title="next chapter">Poisson simulation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/tutorial/curvefit/poisson.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sim.html" title="Poisson simulation"
             >next</a> |</li>
        <li class="right" >
          <a href="curve.html" title="Fitting a curve"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Bumps 0.9.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Tutorial</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="readme.html" >Simple functions</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Fitting Poisson data</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>